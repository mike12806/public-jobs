name: Sync Vault Secret to Kubernetes

permissions:
  contents: read

concurrency:
  group: sync-vault-secret
  cancel-in-progress: true

on:
  schedule:
    - cron: '*/10 * * * *'  # Run every 10 minutes
  workflow_dispatch:

jobs:
  sync-secret:
    runs-on: ubuntu-latest
    timeout-minutes: 7

    env:
      VAULT_ADDR: https://vault.mfaherty.net
      VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}

    steps:
      - name: Checkout gh_hdc
        uses: actions/checkout@v6
        with:
          repository: mike12806/gh_hdc
          token: ${{ secrets.GH_HDC_PAT }}
          path: gh_hdc

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci
          hostname: github-runner-vault-sync
          version: latest

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Fetch Secret YAML from Vault (no log output)
        id: fetch_secret
        run: |
          set -euo pipefail
          # Fetch all data from Vault kubernetes/secret path
          vault_response=$(curl -sSL \
            --header "X-Vault-Token: $VAULT_TOKEN" \
            --header "Content-Type: application/json" \
            "$VAULT_ADDR/v1/kv/data/kubernetes/secret")
          
          # Extract all key-value pairs from the data object
          echo "$vault_response" | jq -r '.data.data' > vault_data.json
          
          # Validate that we got valid content
          if [ ! -s vault_data.json ]; then
            echo "No data received from Vault"
            exit 1
          fi
          
          # Process each key-value pair and create YAML files
          echo "$vault_response" | jq -r '.data.data | keys[]' | while read -r key; do
            echo "Processing key: $key"
            value=$(echo "$vault_response" | jq -r ".data.data[\"$key\"]")
            
            # Check if the value is already valid YAML with apiVersion and kind
            if echo "$value" | grep -q "^apiVersion:" && echo "$value" | grep -q "^kind:"; then
              # It's already a complete Kubernetes manifest
              echo "$value" > "${key}.yaml"
            else
              # Skip non-manifest values (they might be raw secrets that need manual handling)
              echo "Skipping key '$key' - not a valid Kubernetes manifest (missing apiVersion/kind)"
              continue
            fi
            
            # Basic YAML validation for each file
            echo "Running kubectl dry-run validation for $key:"
            if ! kubectl --dry-run=client apply -f "${key}.yaml"; then
              echo "Invalid YAML for key: $key"
              echo "kubectl error details above"
              exit 1
            fi
          done
        env:
          KUBECONFIG: /home/runner/.kube/config

      - name: Apply Secrets to Cluster
        run: |
          # Apply all YAML files that were created from Vault data
          for yaml_file in *.yaml; do
            if [ -f "$yaml_file" ]; then
              echo "Applying $yaml_file to cluster"
              kubectl apply -f "$yaml_file"
            fi
          done
        env:
          KUBECONFIG: /home/runner/.kube/config

      - name: Cleanup
        if: always()
        run: |
          rm -f *.yaml
          rm -f vault_data.json
          rm -f $HOME/.kube/config
          rm -rf $HOME/.kube
