name: Sync Tailscale DNS to Pi-hole

on:
  workflow_dispatch:
  schedule:
    - cron: '*/15 * * * *'  # every 15 minutes

concurrency:
  group: tailscale-dns-pihole-sync
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  sync-dns:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci
          hostname: github-runner-tailscale-dns-sync
          version: latest

      - name: Install dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Get Tailscale DNS records
        id: tailscale_dns
        run: |
          # Get OAuth token for API calls
          TOKEN_RESPONSE=$(curl -s -X POST \
            -d "client_id=${{ secrets.TS_OAUTH_CLIENT_ID }}" \
            -d "client_secret=${{ secrets.TS_OAUTH_SECRET }}" \
            "https://api.tailscale.com/api/v2/oauth/token" 2>&1)
          
          ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token // empty')
          
          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "Error: Could not get OAuth access token"
            exit 1
          fi
          
          # Get all devices in the tailnet
          # Use "-" to represent the tailnet associated with the OAuth token
          # This is the recommended approach per Tailscale API documentation
          DEVICES=$(curl -s \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            "https://api.tailscale.com/api/v2/tailnet/-/devices" 2>&1)
          
          # Validate the response is valid JSON
          if ! echo "$DEVICES" | jq -e . >/dev/null 2>&1; then
            echo "Error: Invalid response from Tailscale API"
            # Only show first 200 chars to avoid leaking sensitive data
            echo "Response preview: ${DEVICES:0:200}"
            exit 1
          fi
          
          # Check if devices array exists and is not null
          DEVICE_COUNT=$(echo "$DEVICES" | jq '(.devices // []) | length')
          echo "Found $DEVICE_COUNT total devices in Tailscale"
          
          # Filter devices that don't have tag:ci and extract IPv4 and hostname
          # Format: ip=hostname (one per line)
          # Use // [] to provide an empty array if .devices is null
          DNS_RECORDS=$(echo "$DEVICES" | jq -r '
            (.devices // [])[] |
            select(.tags == null or (.tags | map(select(. == "tag:ci")) | length == 0)) |
            select(.addresses[]? | startswith("100.")) |
            (.addresses[] | select(startswith("100."))) as $ipv4 |
            ($ipv4 + "=" + .hostname)
          ' | sort -u)
          
          if [[ -z "$DNS_RECORDS" ]]; then
            echo "No DNS records found (excluding tag:ci devices)"
            echo "records=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          RECORD_COUNT=$(echo "$DNS_RECORDS" | wc -l)
          echo "Found $RECORD_COUNT DNS records (excluding tag:ci devices)"
          
          # Save records to output (base64 encode to handle multiline)
          echo "records=$(echo "$DNS_RECORDS" | base64 -w 0)" >> $GITHUB_OUTPUT

      - name: Sync DNS records to Pi-hole
        if: steps.tailscale_dns.outputs.records != ''
        run: |
          # Decode the DNS records
          DNS_RECORDS=$(echo "${{ steps.tailscale_dns.outputs.records }}" | base64 -d)
          
          # Pi-hole host and password
          PIHOLE_HOST="${{ secrets.PRIMARY_PIHOLE_IP_AND_PORT }}"
          PIHOLE_PASSWORD="${{ secrets.PRIMARY_PIHOLE_TOKEN }}"
          
          echo "Authenticating with Pi-hole v6..."
          
          # Pi-hole v6 uses session-based authentication
          # First, authenticate to get a session ID (SID)
          AUTH_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "{\"password\":\"${PIHOLE_PASSWORD}\"}" \
            "http://${PIHOLE_HOST}/api/auth" 2>&1)
          
          AUTH_HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1)
          AUTH_BODY=$(echo "$AUTH_RESPONSE" | sed '$d')
          
          if [[ "$AUTH_HTTP_CODE" != "200" ]]; then
            echo "Error: Failed to authenticate with Pi-hole (HTTP $AUTH_HTTP_CODE)"
            exit 1
          fi
          
          # Extract session ID from response
          SESSION_ID=$(echo "$AUTH_BODY" | jq -r '.session.sid // empty')
          
          if [[ -z "$SESSION_ID" ]]; then
            echo "Error: Could not get session ID from Pi-hole"
            exit 1
          fi
          
          echo "Successfully authenticated with Pi-hole v6"
          echo "Syncing DNS records to Pi-hole..."
          
          RECORDS_PROCESSED=0
          RECORDS_SUCCEEDED=0
          RECORDS_FAILED=0
          
          # Process each record
          while IFS= read -r record; do
            if [[ -z "$record" ]]; then
              continue
            fi
            
            # Split record into IP and hostname
            IPV4=$(echo "$record" | cut -d= -f1)
            HOSTNAME=$(echo "$record" | cut -d= -f2)
            
            RECORDS_PROCESSED=$((RECORDS_PROCESSED + 1))
            
            # Add DNS record in Pi-hole v6 using the REST API
            # Pi-hole v6 uses PUT to /api/config/dns/hosts/{item} to add individual DNS records
            # URL-encode the entry (IP space HOSTNAME) for the URL path
            DNS_ENTRY="${IPV4} ${HOSTNAME}"
            ENCODED_ENTRY=$(echo -n "$DNS_ENTRY" | jq -sRr @uri)
            
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -X PUT \
              -H "Content-Type: application/json" \
              -H "X-FTL-SID: ${SESSION_ID}" \
              "http://${PIHOLE_HOST}/api/config/dns/hosts/${ENCODED_ENTRY}" 2>&1)
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            # Log the HTTP code for debugging
            echo "Record ${HOSTNAME}: HTTP ${HTTP_CODE}"
            
            # Pi-hole v6 returns 200/201 for success, check if already exists is ok
            if [[ "$HTTP_CODE" == "200" ]] || [[ "$HTTP_CODE" == "201" ]] || [[ "$HTTP_CODE" == "204" ]]; then
              RECORDS_SUCCEEDED=$((RECORDS_SUCCEEDED + 1))
            else
              # Check if it failed because entry already exists (which is fine)
              if echo "$BODY" | jq -e '.error' >/dev/null 2>&1; then
                ERROR_MSG=$(echo "$BODY" | jq -r '.error // ""')
                if [[ "$ERROR_MSG" == *"already"* ]] || [[ "$ERROR_MSG" == *"exists"* ]] || [[ "$ERROR_MSG" == *"duplicate"* ]]; then
                  echo "  (already exists, counting as success)"
                  RECORDS_SUCCEEDED=$((RECORDS_SUCCEEDED + 1))
                else
                  echo "  Failed: $ERROR_MSG"
                  RECORDS_FAILED=$((RECORDS_FAILED + 1))
                fi
              else
                echo "  Failed response: ${BODY:0:200}"
                RECORDS_FAILED=$((RECORDS_FAILED + 1))
              fi
            fi
            
          done <<< "$DNS_RECORDS"
          
          # Logout from Pi-hole session
          LOGOUT_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
            -H "X-FTL-SID: ${SESSION_ID}" \
            "http://${PIHOLE_HOST}/api/auth" 2>&1)
          LOGOUT_CODE=$(echo "$LOGOUT_RESPONSE" | tail -n1)
          if [[ "$LOGOUT_CODE" != "200" ]] && [[ "$LOGOUT_CODE" != "204" ]]; then
            echo "Warning: Failed to logout from Pi-hole session (HTTP $LOGOUT_CODE)"
          fi
          
          echo "DNS sync complete: Processed $RECORDS_PROCESSED records, Succeeded: $RECORDS_SUCCEEDED, Failed: $RECORDS_FAILED"
          
          # Fail the job if all records failed
          if [[ "$RECORDS_FAILED" -gt 0 ]] && [[ "$RECORDS_SUCCEEDED" -eq 0 ]]; then
            echo "Error: All records failed to sync"
            exit 1
          fi
